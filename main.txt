1)Disc Scheduling 


import java.util.*;

public class DiskScheduling {
    static int[] arr = {82,170,43,140,24,16,190};
    int head = 50;
    void FCFS(){
        int sum = arr[0] - head;
        sum = Math.abs(sum);
        for(int i=0;i<arr.length-1;i++){
            int n = arr[i] - arr[i+1];
            sum += Math.abs(n);
        }
        System.out.println("Head movements in FCFC is = "+sum);
    }
    void SSTF(){
        int sum=0;
        List<Integer> low = new ArrayList<>();
        List<Integer> high = new ArrayList<>();
        for(int i: arr){
            if(i< head){
                low.add(i);
            }else{
                high.add(i);
            }
        }
        Collections.sort(low);
        Collections.sort(high);
        if(Math.abs(low.get(low.size() - 1) - head) < Math.abs(high.get(0) - head)){
            sum += Math.abs(low.get(0) - head);
            sum += Math.abs((low.get(0) - high.get(high.size() - 1)));
        }else{
            sum += Math.abs(high.get(high.size() - 1 ) - head);
            sum += Math.abs(high.get(high.size()-1) - low.get(0));
        }
        System.out.println("Head movements in SSTF is = "+sum);
    }

    void C_SCAN(){
        int high=0;
        for(int i : arr){
            if(i<head && high<i){
                high = i;
            }
        }
        int sum=0;
        sum += Math.abs(head - 199) + 199 + high;
        System.out.println("Head movements in C-SCAN is = "+sum);
    }

    void SCAN(){
        int[] temp = arr.clone();
        Arrays.sort(temp);
        int sum=0;
        sum += Math.abs(head - 199) + Math.abs(199 - temp[0]);
        System.out.println("Head movements in SCAN is = "+sum);
    }

    public static void main(String[] args) {
        DiskScheduling ds = new DiskScheduling();
        ds.FCFS();
        ds.SSTF();
        ds.SCAN();
        ds.C_SCAN();
    }
}

2) Bankers algo (deadlock avoid)

import java.util.Scanner;
import java.util.Arrays;

public class Bankers {
    static int[][] allocated, need, max;
    static int[] available;
    static int processNum;
    static int resourceNum;
    static boolean[] finished;

    void init() {
        Scanner sc = new Scanner(System.in);

        System.out.println("Enter the number of processes: ");
        processNum = sc.nextInt();

        System.out.println("Enter the number of resources: ");
        resourceNum = sc.nextInt();

        allocated = new int[processNum][resourceNum];
        max = new int[processNum][resourceNum];
        available = new int[resourceNum];
        need = new int[processNum][resourceNum];

        System.out.println("Enter the Allocation matrix: ");
        for (int i = 0; i < processNum; i++) {
            for (int j = 0; j < resourceNum; j++) {
                allocated[i][j] = sc.nextInt();
            }
        }

        System.out.println("Enter the Max matrix: ");
        for (int i = 0; i < processNum; i++) {
            for (int j = 0; j < resourceNum; j++) {
                max[i][j] = sc.nextInt();
            }
        }

        System.out.println("Enter the Available matrix: ");
        for (int i = 0; i < resourceNum; i++) {
            available[i] = sc.nextInt();
        }

        for (int i = 0; i < processNum; i++) {
            for (int j = 0; j < resourceNum; j++) {
                need[i][j] = max[i][j] - allocated[i][j];
            }
        }
    }

    boolean isSafe() {
        int[] work = Arrays.copyOf(available, available.length);
        boolean[] finish = new boolean[processNum];
        int[] safeSequence = new int[processNum];
        int count = 0;

        while (count < processNum) {
            boolean found = false;

            for (int i = 0; i < processNum; i++) {
                if (!finish[i]) {
                    boolean canAllocate = true;

                    for (int j = 0; j < resourceNum; j++) {
                        if (need[i][j] > work[j]) {
                            canAllocate = false;
                            break;
                        }
                    }

                    if (canAllocate) {
                        for (int j = 0; j < resourceNum; j++) {
                            work[j] += allocated[i][j];
                        }
                        safeSequence[count++] = i;
                        finish[i] = true;
                        found = true;
                    }
                }
            }

            if (!found) {
                System.out.println("The system is not in a safe state.");
                return false;
            }
        }

        System.out.println("The system is in a safe state.");
        System.out.print("Safe sequence is: "+ Arrays.toString(safeSequence));

        return true;
    }

    void resourceRequest(int requestIndex, int[] request) {
        for (int i = 0; i < resourceNum; i++) {
            if (request[i] > need[requestIndex][i]) {
                System.out.println("Process exceeds its maximum need, cannot allocate.");
                return;
            }
        }

        for (int i = 0; i < resourceNum; i++) {
            if (request[i] > available[i]) {
                System.out.println("Resources are not available, cannot allocate.");
                return;
            }
        }

        // allocate resources
        for (int i = 0; i < resourceNum; i++) {
            available[i] -= request[i];
            allocated[requestIndex][i] += request[i];
            need[requestIndex][i] -= request[i];
        }

        // Check if the system is in a safe state
        if (isSafe()) {
            System.out.println("Request can be granted. System remains in a safe state.");
        } else {

            for (int i = 0; i < resourceNum; i++) {
                available[i] += request[i];
                allocated[requestIndex][i] -= request[i];
                need[requestIndex][i] += request[i];
            }
            System.out.println("Request cannot be granted. System would not be in a safe state.");
        }
    }

    public static void main(String[] args) {
        Bankers bankers = new Bankers();
        bankers.init();

        bankers.isSafe();

        int requestIndex = 1;
        int[] request = {1, 0, 2};

        System.out.println("Process P" + requestIndex + " requesting resources: " + Arrays.toString(request));
        bankers.resourceRequest(requestIndex, request);
    }
}


3) Deadlock detection 
import java.util.Scanner;
import java.util.Arrays;

public class Detection {
    int processNum, resourceNum;
    int[][] allocated, request;
    int[] available;
    boolean[] finished;

    void init(){
        Scanner sc = new Scanner(System.in);
        System.out.println("Enter number of processes:");
        processNum = sc.nextInt();
        System.out.println("Enter number of resources:");
        resourceNum = sc.nextInt();

        allocated = new int[processNum][resourceNum];
        request = new int[processNum][resourceNum];
        available = new int[resourceNum];
        finished = new boolean[processNum];

        System.out.println("Enter Allocation matrix:");
        for (int i = 0;i<processNum;i++){
            for(int j= 0;j<resourceNum;j++){
                allocated[i][j] = sc.nextInt();
            }
        }

        System.out.println("Enter Request matrix:");
        for (int i = 0;i<processNum;i++){
            for(int j= 0;j<resourceNum;j++){
                request[i][j] = sc.nextInt();
                if (request[i][j] != 0) {
                    finished[i] = false; // If there's a request, mark the process as not finished
                }
            }
        }

        System.out.println("Enter Available matrix:");
        for (int i = 0;i<resourceNum;i++){
            available[i] = sc.nextInt();
        }
    }

    void checkDeadlock(){
        int[] work = Arrays.copyOf(available, available.length);
        boolean deadlock = false;

        for (int i = 0; i < processNum; i++) {
            if (!finished[i]) {
                boolean canProceed = true;
                for (int j = 0; j < resourceNum; j++) {
                    if (request[i][j] > work[j]) {
                        canProceed = false;
                        break;
                    }
                }
                if (canProceed) {
                    // Process can proceed, release resources
                    for (int j = 0; j < resourceNum; j++) {
                        work[j] += allocated[i][j];
                    }
                    finished[i] = true;
                    i = -1; // Reset to check from the beginning
                }
            }
        }

        for (int i = 0; i < processNum; i++) {
            if (!finished[i]) {
                System.out.println("Process P" + i + " is deadlocked");
                deadlock = true;
            }
        }
        if (!deadlock) {
            System.out.println("No deadlock detected.");
        }
    }

    public static void main(String[] args) {
        Detection detect = new Detection();
        detect.init();
        detect.checkDeadlock();
    }
}


4) FCFS

public class FCFS {
    static int[] process = {1,2,3,4,5};
    static int[] AT = {0,2,4,6,8};
    static int[] BT = {3,6,4,5,2};
    static int[] FT = new int[5];
    static int[] TT = new int[5];
    static int[] WT = new int[5];

    void fcfs(){

        int time = 0;

        for(int i=0;i<5;i++){
            FT[i] = time + BT[i];
            time += BT[i];
        }
        for(int i=0;i<5;i++){
            TT[i] = FT[i] - AT[i];
        }
        for(int i=0;i<5;i++){
            WT[i] = TT[i] - BT[i];
        }
    }
    void averageTiming(){
        float avgTT=0;
        float avgWT=0;
        for(int i=0;i<5;i++){
            avgTT += TT[i];
        }
        avgTT = avgTT/5;
        System.out.println("Average Turn around time = "+avgTT);

        for(int i=0;i<5;i++){
            avgWT += WT[i];
        }
        avgWT = avgWT/5;
        System.out.println("Average Waiting time = "+avgWT);

    }

    public static void main(String[] args) {
        FCFS example = new FCFS();
        example.fcfs();

        System.out.println("FCFS Scheduling: ");
        System.out.println("Process    ArrivalTime    BurstTime   FinishTime   TotalTime   WaitingTime");
        for (int i = 0; i < 5; i++) {
            System.out.println(process[i] + "         " + AT[i] + "               " + BT[i] + "           " + FT[i] + "            "  + TT[i] + "            " + WT[i]);
        }

        example.averageTiming();
    }
}


5) SJF , p/np
import java.util.ArrayList;
import java.util.List;

public class SJF {
    static int[] p = {1, 2, 3, 4};
    static int[] at = {0, 1, 2, 4};
    static int[] bt = {5, 3, 3, 1};
    static int[] ft = new int[4];
    static int[] tt = new int[4];
    static int[] wt = new int[4];
    static int[] remainingBt = bt.clone(); // Added: Clone the burst times for remaining burst times

    void sjfP(){
        List<Integer> queue = new ArrayList<>();
        int timer = 0;
        int n= p.length;
        int currentProcess = -1;
        while(n > 0){
            for(int i = 0; i < at.length; i++){
                if(at[i] == timer && !queue.contains(p[i])){
                    queue.add(p[i]);
                }
            }
            int min = Integer.MAX_VALUE; // Changed: Use Integer.MAX_VALUE instead of 9999
            for(int i = 0; i < queue.size(); i++){
                if(remainingBt[queue.get(i) - 1] != 0 && remainingBt[queue.get(i) - 1] < min){
                    min = remainingBt[queue.get(i) - 1];
                    currentProcess = queue.get(i) - 1;
                }
            }

            if (currentProcess != -1) {
                remainingBt[currentProcess]--; // Changed: Use remainingBt array
                if(remainingBt[currentProcess] == 0){
                    n--;
                    ft[currentProcess] = timer + 1; // Changed: Correct finish time calculation
                    queue.remove((Integer)(currentProcess + 1)); // Changed: Correct element removal
                    currentProcess = -1; // Added: Reset currentProcess
                }
            }
            timer++;
        }
        for (int i = 0; i < 4; i++) {
            tt[i] = ft[i] - at[i];
        }
        for (int i = 0; i < 4; i++) {
            wt[i] = tt[i] - (bt[i]);
        }
    } 

  
  void sjfNP() {
        List<Integer> list = new ArrayList<>();
        int time = 0;
        int totaltime = 0;
        list.add(p[0]);
        while (!list.isEmpty()) {
            int i = list.remove(0) - 1;
            int j = i + 1;
            while (time < bt[i]) {
                if (j < 4 && time + totaltime == at[j]) {
                    if (list.isEmpty())
                        list.add(p[j++]);
                    else {
                        int index = -1;
                        for (int k = 0; k < list.size(); k++) {
                            if (bt[list.get(k) - 1] > bt[j]) {
                                index = k;
                                break;
                            }
                        }
                        if (index != -1)
                            list.add(index, p[j]);
                        else
                            list.add(p[j]);
                        j++;
                    }
                }
                time++;
            }
            totaltime += bt[i];
            ft[i] = totaltime;
            time = 0;
        }
        for (int i = 0; i < 4; i++) {
            tt[i] = ft[i] - at[i];
        }
        for (int i = 0; i < 4; i++) {
            wt[i] = tt[i] - bt[i];
        }
    }

    void display() {
        System.out.println("Process    ArrivalTime    BurstTime   FinishTime    TotalTime   WaitingTime");
        for (int i = 0; i < 4; i++) {
            System.out.println(p[i] + "             " + at[i] + "               " + bt[i] + "            " + ft[i] + "         " + tt[i] + "          " + wt[i]);
        }
    }

    public static void main(String[] args) {
        SJF np = new SJF();
        np.sjfNP();
        np.display();
        np.sjfP();
        np.display();
    }
}


6) Round Robin
import java.util.ArrayList;

public class RoundRobin {
    static int[] process = {0, 1, 2, 3, 4};
    static int[] originalBT = {3, 6, 4, 5, 2}; // Original Burst Time to use in final printout
    static int TQ = 2; // Time Quantum
    static int[] AT = {0, 2, 4, 6, 8};
    static int[] BT = {3, 6, 4, 5, 2};
    static int[] FT = new int[5];
    static int[] TT = new int[5];
    static int[] WT = new int[5];

    void Calculate() {
        int timer = 0, totalTime = 0;
        int processCount = 1;
        ArrayList<Integer> list = new ArrayList<>();
        ArrayList<Integer> executionSequence = new ArrayList<>(); // List to store execution sequence
        list.add(process[0]);

        while (!list.isEmpty()) {
            int currentProcess = list.remove(0);
            executionSequence.add(currentProcess); // Add the current process to execution sequence
            while (timer < TQ) {
                if (BT[currentProcess] == 0) {
                    break;
                }
                totalTime++;
                timer++;
                BT[currentProcess] = BT[currentProcess] - 1;
                if (processCount < 5 && AT[processCount] == totalTime) {
                    list.add(processCount);
                    processCount++;
                }
            }
            if (BT[currentProcess] != 0) {
                list.add(currentProcess);
            } else {
                FT[currentProcess] = totalTime;
            }
            timer = 0;
        }

        for (int i = 0; i < 5; i++) {
            TT[i] = FT[i] - AT[i];
            WT[i] = TT[i] - originalBT[i];
        }

        // Print execution sequence
        System.out.println("Execution Sequence: ");
        for (int i : executionSequence) {
            System.out.print("P" + i + " ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        RoundRobin r = new RoundRobin();
        r.Calculate();
        System.out.println("RR Scheduling: ");
        System.out.println("Process    ArrivalTime    BurstTime   FinishTime   TotalTime   WaitingTime");
        for (int i = 0; i < 5; i++) {
            System.out.printf("%-10d %-13d %-11d %-12d %-11d %-12d\n", process[i], AT[i], originalBT[i], FT[i], TT[i], WT[i]);
        }
    }
}


7) priority scheduling 

import java.util.ArrayList;
import java.util.List;

public class Priority {
    static int[] process = {1,2,3,4,5};    //Process ID
    static int[] AT = {0,2,4,6,8};       //Arrival Time
    static int[] BT = {3,6,4,5,2};    //Burst Time
    static int[] priority = {5, 4, 3, 2, 1}; // Priority of processes
    static int[] FT = new int[5];   //Finish Time
    static int[] TT = new int[5];     //Total execution time
    static int[] WT = new int[5];  //Waiting Time

    void preemptiveP(){
        int timer = 0;
        int[] burstTime = BT.clone();
        int n= process.length;
        int currentProcess = -1;
        List<Integer> queue = new ArrayList<>();
        while(n>0){
            for(int i=0;i< burstTime.length;i++){
                if(timer == AT[i]){
                    queue.add(process[i]);
                }
            }
            int high=999;
            for(int i=0;i<queue.size();i++){
                if(high > priority[queue.get(i) - 1]){
                    high = priority[queue.get(i) - 1];
                    currentProcess = queue.get(i) - 1;
                }
            }
            if(burstTime[currentProcess] == 0){
                FT[currentProcess] = timer+1;
                queue.remove((Integer) (currentProcess+1));
                n--;
            }
            timer++;
            burstTime[currentProcess]--;
        }
        for (int i = 0; i < 5; i++) {
            TT[i] = FT[i] - AT[i];
        }
        for (int i = 0; i < 5; i++) {
            WT[i] = TT[i] - (BT[i]);
        }
    }

    void nonPreemptive(){
        int timer=0;
        int n = process.length;
        List<Integer> queue = new ArrayList<>();
        while(n>0){
            for(int i=0;i<AT.length;i++){
                if(timer>=AT[i] && !queue.contains(process[i]) && FT[i] == 0){
                    queue.add(process[i]);
                }
            }
            int high = 999;
            int currentProcess = -1;
            for(int i=0;i< queue.size();i++){
                if(priority[queue.get(i)-1]  < high){
                    high=priority[queue.get(i) - 1];
                    currentProcess = queue.get(i) - 1;
                }
            }
            timer += BT[currentProcess]; // Update timer by the burst time of the selected process
            FT[currentProcess] = timer;
            queue.remove((Integer) process[currentProcess]);
            n--;
        }
    }

    public static void main(String[] args) {
        Priority priority = new Priority();
        priority.preemptiveP();

        System.out.println("Process\tArrival\tBurst\tFinish\tTurnaround\tWaiting");
        for (int i = 0; i < process.length; i++) {
            System.out.println(process[i] + "\t\t" + AT[i] + "\t\t" + BT[i] + "\t\t" + FT[i] + "\t\t" + TT[i] + "\t\t" + WT[i]);
        }
        System.out.println("\n\n");
        priority.nonPreemptive();
        System.out.println("Process\tArrival\tBurst\tFinish\tTurnaround\tWaiting");
        for (int i = 0; i < process.length; i++) {
            System.out.println(process[i] + "\t\t" + AT[i] + "\t\t" + BT[i] + "\t\t" + FT[i] + "\t\t" + TT[i] + "\t\t" + WT[i]);
        }
    }
}

8) Memory alloc all

import java.util.Arrays;

public class MemoryAllocation {
    static int blockNum;
    static int processNum;
   
    static void firstFit(int[] blockSize, int[] processSize) {
        int[] allocation = new int[processNum];
        Arrays.fill(allocation, -1);

        for (int i = 0; i < processNum; i++) {
            for (int j = 0; j < blockNum; j++) {
                if (blockSize[j] >= processSize[i]) {
                    allocation[i] = j;
                    blockSize[j] -= processSize[i];
                    break;
                }
            }
        }

        System.out.println("First Fit Allocation:");
        printAllocation(allocation,processSize);
    }
     static void bestFit(int[] blockSize, int[] processSize) {
        int[] allocation = new int[processNum];
        Arrays.fill(allocation, -1);

        for (int i = 0; i < processNum; i++) {
            int bestIndex = -1;
            for (int j = 0; j < blockNum; j++) {
                if (blockSize[j] >= processSize[i]) {
                    if (bestIndex == -1 || blockSize[bestIndex] > blockSize[j]) {
                        bestIndex = j;
                    }
                }
            }
            if (bestIndex != -1) {
                allocation[i] = bestIndex;
                blockSize[bestIndex] -= processSize[i];
            }
        }

        System.out.println("Best Fit Allocation:");
        printAllocation(allocation,processSize);
    }
    static void worstFit(int[] blockSize, int[] processSize) {
        int[] allocation = new int[processNum];
        Arrays.fill(allocation, -1);

        for (int i = 0; i < processNum; i++) {
            int worstIndex = -1;
            for (int j = 0; j < blockNum; j++) {
                if (blockSize[j] >= processSize[i]) {
                    if (worstIndex == -1 || blockSize[worstIndex] < blockSize[j]) {
                        worstIndex = j;
                    }
                }
            }
            if (worstIndex != -1) {
                allocation[i] = worstIndex;
                blockSize[worstIndex] -= processSize[i];
            }
        }

        System.out.println("Worst Fit Allocation:");
        printAllocation(allocation,processSize);
    }

    static void nextFit(int[] blockSize, int[] processSize) {
        int[] allocation = new int[processNum];
        Arrays.fill(allocation, -1);

        int lastIndex = 0;

        for (int i = 0; i < processNum; i++) {
            boolean allocated = false;
            for (int j = 0; j < blockNum; j++) {
                int index = (lastIndex + j) % blockNum;
                if (blockSize[index] >= processSize[i]) {
                    allocation[i] = index;
                    blockSize[index] -= processSize[i];
                    lastIndex = index;
                    allocated = true;
                    break;
                }
            }
            if (!allocated) {
                System.out.println("Process " + i + " not allocated");
            }
        }

        System.out.println("Next Fit Allocation:");
        printAllocation(allocation,processSize);
    }

    static void printAllocation(int[] allocation, int[] processSize) {
        System.out.println("Process No.\tProcess Size\tBlock No.");
        for (int i = 0; i < processNum; i++) {
            System.out.print(i + "\t\t    " + processSize[i] + "\t\t\t      ");
            if (allocation[i] != -1) {
                System.out.println(allocation[i]);
            } else {
                System.out.println("Not Allocated");
            }
        }
        System.out.println();
    }

    public static void main(String[] args) {
        int[] blockSize = {100, 500, 200, 300, 600};
        int[] processSize = {212, 417, 112, 426};

        blockNum = blockSize.length;
        processNum = processSize.length;

        System.out.println("Initial Block Sizes: " + Arrays.toString(blockSize));
        System.out.println("Process Sizes: " + Arrays.toString(processSize));
        System.out.println();


        firstFit(Arrays.copyOf(blockSize, blockSize.length), processSize);

        bestFit(Arrays.copyOf(blockSize, blockSize.length), processSize);

        worstFit(Arrays.copyOf(blockSize, blockSize.length), processSize);

        nextFit(Arrays.copyOf(blockSize, blockSize.length), processSize);

    }
}


9) First fit

import java.util.Arrays;

public class FirstFit {
    static int blockNum;
    static int processNum;

    static void firstFit(int[] blockSize, int[] processSize) {
        int[] allocation = new int[processNum];
        Arrays.fill(allocation, -1);

        for (int i = 0; i < processNum; i++) {
            for (int j = 0; j < blockNum; j++) {
                if (blockSize[j] >= processSize[i]) {
                    allocation[i] = j;
                    blockSize[j] -= processSize[i];
                    break;
                }
            }
        }

        System.out.println("First Fit Allocation:");
        printAllocation(allocation, processSize);
    }

    static void printAllocation(int[] allocation, int[] processSize) {
        System.out.println("Process No.\tProcess Size\tBlock No.");
        for (int i = 0; i < processNum; i++) {
            System.out.print(i + "\t\t" + processSize[i] + "\t\t");
            if (allocation[i] != -1) {
                System.out.println(allocation[i]);
            } else {
                System.out.println("Not Allocated");
            }
        }
        System.out.println();
    }

    public static void main(String[] args) {
        int[] blockSize = {100, 500, 200, 300, 600};
        int[] processSize = {212, 417, 112, 426};

        blockNum = blockSize.length;
        processNum = processSize.length;

        System.out.println("Initial Block Sizes: " + Arrays.toString(blockSize));
        System.out.println("Process Sizes: " + Arrays.toString(processSize));
        System.out.println();

        firstFit(Arrays.copyOf(blockSize, blockSize.length), processSize);
    }
}



10) Next fit

import java.util.Arrays;

public class NextFit {
    static int blockNum;
    static int processNum;

    static void nextFit(int[] blockSize, int[] processSize) {
        int[] allocation = new int[processNum];
        Arrays.fill(allocation, -1);

        int lastIndex = 0;

        for (int i = 0; i < processNum; i++) {
            boolean allocated = false;
            for (int j = 0; j < blockNum; j++) {
                int index = (lastIndex + j) % blockNum;
                if (blockSize[index] >= processSize[i]) {
                    allocation[i] = index;
                    blockSize[index] -= processSize[i];
                    lastIndex = index;
                    allocated = true;
                    break;
                }
            }
            if (!allocated) {
                System.out.println("Process " + i + " not allocated");
            }
        }

        System.out.println("Next Fit Allocation:");
        printAllocation(allocation, processSize);
    }

    static void printAllocation(int[] allocation, int[] processSize) {
        System.out.println("Process No.\tProcess Size\tBlock No.");
        for (int i = 0; i < processNum; i++) {
            System.out.print(i + "\t\t" + processSize[i] + "\t\t");
            if (allocation[i] != -1) {
                System.out.println(allocation[i]);
            } else {
                System.out.println("Not Allocated");
            }
        }
        System.out.println();
    }

    public static void main(String[] args) {
        int[] blockSize = {100, 500, 200, 300, 600};
        int[] processSize = {212, 417, 112, 426};

        blockNum = blockSize.length;
        processNum = processSize.length;

        System.out.println("Initial Block Sizes: " + Arrays.toString(blockSize));
        System.out.println("Process Sizes: " + Arrays.toString(processSize));
        System.out.println();

        nextFit(Arrays.copyOf(blockSize, blockSize.length), processSize);
    }
}


11) Best fit

import java.util.Arrays;

public class BestFit {
    static int blockNum;
    static int processNum;

    static void bestFit(int[] blockSize, int[] processSize) {
        int[] allocation = new int[processNum];
        Arrays.fill(allocation, -1);

        for (int i = 0; i < processNum; i++) {
            int bestIndex = -1;
            for (int j = 0; j < blockNum; j++) {
                if (blockSize[j] >= processSize[i]) {
                    if (bestIndex == -1 || blockSize[bestIndex] > blockSize[j]) {
                        bestIndex = j;
                    }
                }
            }
            if (bestIndex != -1) {
                allocation[i] = bestIndex;
                blockSize[bestIndex] -= processSize[i];
            }
        }

        System.out.println("Best Fit Allocation:");
        printAllocation(allocation, processSize);
    }

    static void printAllocation(int[] allocation, int[] processSize) {
        System.out.println("Process No.\tProcess Size\tBlock No.");
        for (int i = 0; i < processNum; i++) {
            System.out.print(i + "\t\t" + processSize[i] + "\t\t");
            if (allocation[i] != -1) {
                System.out.println(allocation[i]);
            } else {
                System.out.println("Not Allocated");
            }
        }
        System.out.println();
    }

    public static void main(String[] args) {
        int[] blockSize = {100, 500, 200, 300, 600};
        int[] processSize = {212, 417, 112, 426};

        blockNum = blockSize.length;
        processNum = processSize.length;

        System.out.println("Initial Block Sizes: " + Arrays.toString(blockSize));
        System.out.println("Process Sizes: " + Arrays.toString(processSize));
        System.out.println();

        bestFit(Arrays.copyOf(blockSize, blockSize.length), processSize);
    }
}



12)Worst Fit

import java.util.Arrays;

public class WorstFit {
    static int blockNum;
    static int processNum;

    static void worstFit(int[] blockSize, int[] processSize) {
        int[] allocation = new int[processNum];
        Arrays.fill(allocation, -1);

        for (int i = 0; i < processNum; i++) {
            int worstIndex = -1;
            for (int j = 0; j < blockNum; j++) {
                if (blockSize[j] >= processSize[i]) {
                    if (worstIndex == -1 || blockSize[worstIndex] < blockSize[j]) {
                        worstIndex = j;
                    }
                }
            }
            if (worstIndex != -1) {
                allocation[i] = worstIndex;
                blockSize[worstIndex] -= processSize[i];
            }
        }

        System.out.println("Worst Fit Allocation:");
        printAllocation(allocation, processSize);
    }

    static void printAllocation(int[] allocation, int[] processSize) {
        System.out.println("Process No.\tProcess Size\tBlock No.");
        for (int i = 0; i < processNum; i++) {
            System.out.print(i + "\t\t" + processSize[i] + "\t\t");
            if (allocation[i] != -1) {
                System.out.println(allocation[i]);
            } else {
                System.out.println("Not Allocated");
            }
        }
        System.out.println();
    }

    public static void main(String[] args) {
        int[] blockSize = {100, 500, 200, 300, 600};
        int[] processSize = {212, 417, 112, 426};

        blockNum = blockSize.length;
        processNum = processSize.length;

        System.out.println("Initial Block Sizes: " + Arrays.toString(blockSize));
        System.out.println("Process Sizes: " + Arrays.toString(processSize));
        System.out.println();

        worstFit(Arrays.copyOf(blockSize, blockSize.length), processSize);
    }
}


13) Page replacement w/o chance

import java.util.*;

public class PageReplacement {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.print("Enter number of frames: ");
        int numFrames = scanner.nextInt();

        System.out.print("Enter number of pages: ");
        int numPages = scanner.nextInt();

        int[] pageReferenceString = new int[numPages];
        System.out.print("Enter page reference string: ");
        for (int i = 0; i < numPages; i++) {
            pageReferenceString[i] = scanner.nextInt();
        }

       // FIFO(pageReferenceString, numFrames);
        LRU(pageReferenceString, numFrames);
        Optimal(pageReferenceString, numFrames);

        scanner.close();
    }

    // FIFO Algorithm
    public static void FIFO(int[] pageReferenceString, int numFrames) {
        int totalPageFaults = 0;
        Queue<Integer> frameQueue = new LinkedList<>();
        Set<Integer> frameSet = new HashSet<>();

        System.out.println("\nFIFO Algorithm:");

        for (int page : pageReferenceString) {
            if (!frameSet.contains(page)) {
                totalPageFaults++;
                if (frameQueue.size() == numFrames) {
                    int removedPage = frameQueue.poll();
                    frameSet.remove(removedPage);
                }
                frameQueue.offer(page);
                frameSet.add(page);
            }
            System.out.println("Frame: " + frameQueue);
        }

        System.out.println("Total page faults: " + totalPageFaults);
    } 

    // LRU Algorithm
    public static void LRU(int[] pageReferenceString, int numFrames) {
        int totalPageFaults = 0;
        List<Integer> frames = new ArrayList<>();
        Map<Integer, Integer> lastUsed = new HashMap<>();

        System.out.println("\nLRU Algorithm:");

        for (int i = 0; i < pageReferenceString.length; i++) {
            int page = pageReferenceString[i];
            if (!frames.contains(page)) {
                if (frames.size() == numFrames) {
                    int lruPage = Collections.min(lastUsed.entrySet(), Map.Entry.comparingByValue()).getKey();
                    frames.remove((Integer) lruPage);
                    lastUsed.remove(lruPage);
                }
                frames.add(page);
                totalPageFaults++;
            }
            lastUsed.put(page, i);
            System.out.println("Frame: " + frames);
        }

        System.out.println("Total page faults: " + totalPageFaults);
    }

    // Optimal Algorithm
    public static void Optimal(int[] pageReferenceString, int numFrames) {
        int totalPageFaults = 0;
        List<Integer> frames = new ArrayList<>();

        System.out.println("\nOptimal Algorithm:");

        for (int i = 0; i < pageReferenceString.length; i++) {
            int currentPage = pageReferenceString[i];
            if (!frames.contains(currentPage)) {
                if (frames.size() == numFrames) {
                    int indexToReplace = -1;
                    int farthestUsage = -1;

                    for (int j = 0; j < frames.size(); j++) {
                        int nextUse = nextUsage(pageReferenceString, i, frames.get(j));
                        if (nextUse > farthestUsage) {
                            farthestUsage = nextUse;
                            indexToReplace = j;
                        }
                    }

                    frames.set(indexToReplace, currentPage);
                } else {
                    frames.add(currentPage);
                }
                totalPageFaults++;
            }
            System.out.println("Frame " + (i + 1) + ": " + frames);
        }

        System.out.println("Total page faults: " + totalPageFaults);
    }

    // Helper method to find the next usage of a page in the page reference string
    public static int nextUsage(int[] pageReferenceString, int currentIndex, int page) {
        for (int i = currentIndex + 1; i < pageReferenceString.length; i++) {
            if (pageReferenceString[i] == page) {
                return i;
            }
        }
        return Integer.MAX_VALUE;
    }
}



14) Page replacement with chance

import java.util.*;

public class PageReplacementwithChance {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.print("Enter number of frames: ");
        int numFrames = scanner.nextInt();

        System.out.print("Enter number of pages: ");
        int numPages = scanner.nextInt();

        int[] pageReferenceString = new int[numPages];
        System.out.print("Enter page reference string: ");
        for (int i = 0; i < numPages; i++) {
            pageReferenceString[i] = scanner.nextInt();
        }

        FIFO(pageReferenceString, numFrames);
        LRU(pageReferenceString, numFrames);
        Optimal(pageReferenceString, numFrames);
        secondChance(pageReferenceString, numFrames);

        scanner.close();
    }

    // FIFO Algorithm
    public static void FIFO(int[] pageReferenceString, int numFrames) {
        int totalPageFaults = 0;
        Queue<Integer> frameQueue = new LinkedList<>();
        Set<Integer> frameSet = new HashSet<>();

        System.out.println("\nFIFO Algorithm:");

        for (int page : pageReferenceString) {
            if (!frameSet.contains(page)) {
                totalPageFaults++;
                if (frameQueue.size() == numFrames) {
                    int removedPage = frameQueue.poll();
                    frameSet.remove(removedPage);
                }
                frameQueue.offer(page);
                frameSet.add(page);
            }
            System.out.println("Frame: " + frameQueue);
        }

        System.out.println("Total page faults: " + totalPageFaults);
    }

    // LRU Algorithm
    public static void LRU(int[] pageReferenceString, int numFrames) {
        int totalPageFaults = 0;
        List<Integer> frames = new ArrayList<>();
        Map<Integer, Integer> lastUsed = new HashMap<>();

        System.out.println("\nLRU Algorithm:");

        for (int i = 0; i < pageReferenceString.length; i++) {
            int page = pageReferenceString[i];
            if (!frames.contains(page)) {
                if (frames.size() == numFrames) {
                    int lruPage = Collections.min(lastUsed.entrySet(), Map.Entry.comparingByValue()).getKey();
                    frames.remove((Integer) lruPage);
                    lastUsed.remove(lruPage);
                }
                frames.add(page);
                totalPageFaults++;
            }
            lastUsed.put(page, i);
            System.out.println("Frame: " + frames);
        }

        System.out.println("Total page faults: " + totalPageFaults);
    }

    // Optimal Algorithm
    public static void Optimal(int[] pageReferenceString, int numFrames) {
        int totalPageFaults = 0;
        List<Integer> frames = new ArrayList<>();

        System.out.println("\nOptimal Algorithm:");

        for (int i = 0; i < pageReferenceString.length; i++) {
            int currentPage = pageReferenceString[i];
            if (!frames.contains(currentPage)) {
                if (frames.size() == numFrames) {
                    int indexToReplace = -1;
                    int farthestUsage = -1;

                    for (int j = 0; j < frames.size(); j++) {
                        int nextUse = nextUsage(pageReferenceString, i, frames.get(j));
                        if (nextUse > farthestUsage) {
                            farthestUsage = nextUse;
                            indexToReplace = j;
                        }
                    }

                    frames.set(indexToReplace, currentPage);
                } else {
                    frames.add(currentPage);
                }
                totalPageFaults++;
            }
            System.out.println("Frame " + (i + 1) + ": " + frames);
        }

        System.out.println("Total page faults: " + totalPageFaults);
    }

    // Second Chance (Clock) Algorithm
    public static void secondChance(int[] pageReferenceString, int numFrames) {
        int totalPageFaults = 0;
        Queue<Integer> frameQueue = new LinkedList<>();
        Queue<Boolean> referenceBitQueue = new LinkedList<>(); // Keeps track of the reference bit for each page
        Set<Integer> frameSet = new HashSet<>();

        System.out.println("\nSecond Chance (Clock) Algorithm:");

        for (int page : pageReferenceString) {
            if (!frameSet.contains(page)) {
                totalPageFaults++;
                if (frameQueue.size() == numFrames) {
                    while (true) {
                        int currentPage = frameQueue.poll();
                        boolean referenceBit = referenceBitQueue.poll();
                        if (referenceBit) { // If reference bit is set, clear it and give the page a second chance
                            referenceBitQueue.offer(false);
                            frameQueue.offer(currentPage);
                        } else {
                            frameSet.remove(currentPage); // Evict the page if its reference bit is not set
                            break;
                        }
                    }
                }
                frameQueue.offer(page);
                referenceBitQueue.offer(true); // Set the reference bit for the new page
                frameSet.add(page);
            } else {
                // If the page is already in memory, set its reference bit to true
                int size = frameQueue.size();
                for (int i = 0; i < size; i++) {
                    int currentPage = frameQueue.poll();
                    boolean referenceBit = referenceBitQueue.poll();
                    if (currentPage == page) {
                        referenceBitQueue.offer(true); // Set the reference bit to true
                    } else {
                        frameQueue.offer(currentPage);
                        referenceBitQueue.offer(referenceBit);
                    }
                }
            }
            System.out.println("Frame: " + frameQueue);
        }

        System.out.println("Total page faults: " + totalPageFaults);
    }

    // Helper method to find the next usage of a page in the page reference string
    public static int nextUsage(int[] pageReferenceString, int currentIndex, int page) {
        for (int i = currentIndex + 1; i < pageReferenceString.length; i++) {
            if (pageReferenceString[i] == page) {
                return i;
            }
        }
        return Integer.MAX_VALUE;
    }
}




PHASE 1

import java.io.*;
import java.util.Arrays;

public class Phase1 {

    //Creating a virtual box
    static char[][] M = new char[100][4];          //Physical Memory array
    static char[] IR = new char[4];                //Instruction register to load instructions from memory
    static char[] R = new char[4];                 // General Purpose register
    static char[] buffer = new char[40];           // buffer to store the line from input file
    static char[] output_buffer = new char[50];    //  Store the output of the file in this array before printing in the output.txt
    private int IC, SI;                            // instruction counter
    private boolean C;                             // Toggle bit
    private final BufferedReader read = new BufferedReader(new InputStreamReader(System.in));
    private final BufferedWriter output = new BufferedWriter(new OutputStreamWriter(System.out));
    String line;                                   // Take single line from file and store it int this line variable;
    int program_card_line = 0;

    public Phase1() throws IOException {
    }

    // To initialise the memory contents to Null values
    public void init() {
        for (int i = 0; i < 100; i++) {
            for (int j = 0; j < 4; j++) {
                M[i][j] = '\0';
            }
        }
        for (int i = 0; i < 4; i++) {
            IR[i] = '\0';
            R[i] = '\0';
        }
        C = false;
    }

    // Load is used to load all the instructions into the memory
    // It also clears all the arrays before the execution of new program
    // Used recursion to execute the new program and stops when there is no next line to read after the $end instruction
    void load() throws IOException {
        boolean readDTA = false;                  // Read data is taken so to check whether the data card has been read or not. If the data card is read then start reading the data line.

        while ((line = read.readLine()) != null) {
            buffer = line.toCharArray();

            if (buffer[0] == '$' && buffer[1] == 'D' && buffer[3] == 'A') {
                readDTA = true;                                                     // Make the read data line true
            }

            if (buffer.length >= 4 && buffer[0] == '$' && buffer[1] == 'A' && buffer[3] == 'J') {
                init();
            } else if (buffer[0] == '$' && buffer[1] == 'E' && buffer[3] == 'D') {
                program_card_line = 0;
                load();                                                            // Uses recursion if the line reads $END and if the next line is null then terminates the code or else star executing the next line of code,
            }

            // Stores the program card into the memory
            else if (!readDTA) {
                int x = 0;
                int loop = program_card_line * 10;

                for (int i = loop; i < loop + 10; i++) {
                    if (buffer[x] == 'H') {
                        M[i][0] = 'H';
                        for (int j = 1; j < 4; j++) {
                            M[i][j] = ' ';
                        }
                        x++;
                    } else {
                        for (int j = 0; j < 4; j++) {
                            if (x < buffer.length && buffer[x] == '\u0000') {
                                break;
                            } else {
                                if (x < buffer.length) {
                                    M[i][j] = buffer[x++];
                                }
                            }
                        }
                    }
                    if (x >= buffer.length || buffer[x] == '\u0000') {
                        break;
                    }
                }
                System.out.println(buffer);
                program_card_line++;
            } else if (readDTA) {
                IC = 0;
             




   start_execution();
            }
        }
    }

    private void start_execution() throws IOException {
        IC = 0;
        EXECUTEUSERPROGRAM();
    }

    public void EXECUTEUSERPROGRAM() throws IOException {
        int IC = 0;
        int j = 0;

        while (M[IC][j] != 'H') {

            while (j < 4) {
                IR[j] = M[IC][j];
                j++;
            }
            IC++;
            System.out.println(IR);
            if (IR[0] == 'G' && IR[1] == 'D') {
                System.out.println("Enter data:");
                String data = read.readLine();         // read the next line after $DTA into data
                SI = 1;
                MOS(SI, data);
            } else if (IR[0] == 'P' && IR[1] == 'D') {
                SI = 2;
                MOS(SI, "");
            } else if (IR[0] == 'L' && IR[1] == 'R') {
                int m1, m2 = 0;
                m1 = Integer.parseInt(String.valueOf(IR[2])) * 10 + Integer.parseInt(String.valueOf(IR[3]));
                while (m2 < 4) {
                    R[m2] = M[m1][m2];
                    m2++;
                }
            } else if (IR[0] == 'S' && IR[1] == 'R') {
                int m1, m2;
                m1 = Integer.parseInt(String.valueOf(IR[2])) * 10 + Integer.parseInt(String.valueOf(IR[3]));
                m2 = 0;
                while (m2 < 4) {
                    M[m1][m2] = R[m2];
                    m2++;
                }
            } else if (IR[0] == 'C' && IR[1] == 'R') {
                int m1, m2;
                m1 = Integer.parseInt(String.valueOf(IR[2])) * 10 + Integer.parseInt(String.valueOf(IR[3]));
                m2 = 0;

                String l1 = Arrays.toString(R);
                l1 = l1.replaceAll("[\\[\\] ,]", "");  // produce a string with no spaces
                String l2 = String.valueOf(M[m1][m2++]) + String.valueOf(M[m1][m2++]) + String.valueOf(M[m1][m2++]) + String.valueOf(M[m1][m2]);

                if (l1.equals(l2)) {
                    C = true;
                }
            } else if (IR[0] == 'B' && IR[1] == 'T') {
                if (C) {
                    int m1, m2;
                    m1 = Integer.parseInt(String.valueOf(IR[2])) * 10 + Integer.parseInt(String.valueOf(IR[3]));
                    IC = m1;
                }
            }
            j = 0;
        }
        if (M[IC][j] == 'H') {

            SI = 3;
            MOS(SI, "");
        }
    }

    public void MOS(int si, String data) throws IOException {
        switch (SI) {
            // GD instruction execution
            case 1:
                // To get the operand number from instruction e.g.GD10 we need 10
                int m1 = Integer.parseInt(String.valueOf(IR[2])) * 10;
                int m2 = 0;
                int length = data.length();
                int count_data = 0;
                for (int i = 0; i < 10; i++) {
                    while (m2 < 4) {
                        if (count_data < length) {
                            M[m1][m2] = data.charAt(count_data++);
                            m2++;
                        } else {
                            break;
                        }
                    }
                    m1++;
                    m2 = 0;
                }

                // Print the contents of memory (M array)
                for (int n = 0; n < 100; n++) {
                    for (int j = 0; j < 4; j++) {
                        System.out.print("[" + n + "] [" + j + "] : " + M[n][j] + "  ");
                    }
                    System.out.println();
                }
                break;

            // PD instruction execution
            case 2:
                int p1 = Integer.parseInt(String.valueOf(IR[2])) * 10;
                int p2 = 0;
                System.out.println();
                int count_buffer = 0;
                for (int i = 0; i < 10; i++) {
                    while (p2 < 4) {

                        if (M[p1][p2] == '\0') {
                            break;
                        } else {
                            output_buffer[count_buffer++] = M[p1][p2];
                            p2++;
                        }
                    }

                    p1++;
                    p2 = 0;

                }

                // Print the output buffer
                for (char buf : output_buffer) {
                    if (buf == '\0') {
                        break;
                    } else {
                        System.out.print(buf);
                    }
                }
                System.out.println(); // Print a newline after each PD
                break;

            case 3:
                // Terminate the program
                break;

            default:
                // Handle unknown system interrupt
                break;
        }
    }

    public static void main(String[] args) throws IOException {
        Phase1 p1 = new Phase1();
        System.out.println("\n");
        p1.load();
    }
}


SS

1.	Write a shell script program for different string handling functions.
ANS.  
#!/bin/bash

string_length() {
    local str="$1"
    echo "${#str}"
}

substring() {
    local str="$1"
    local position="$2"
    local length="$3"
    echo "${str:$position:$length}"
}

string_replace() {
    local str="$1"
    local search="$2"
    local replace="$3"
    echo "${str//$search/$replace}"
}

string_concatenate() {
    local str1="$1"
    local str2="$2"
    echo "${str1}${str2}"
}


echo "String Handling Functions in Shell Script"

# Example string
example_string="Hello, World!"

# Get the length of the string
length=$(string_length "$example_string")
echo "Length of '$example_string' is: $length"

# Extract a substring (e.g., starting at position 7 with length 5)
substring_result=$(substring "$example_string" 7 5)
echo "Substring of '$example_string' from position 7 with length 5 is: '$substring_result'"

# Replace a substring (e.g., replace 'World' with 'Shell')
replace_result=$(string_replace "$example_string" "World" "Shell")
echo "String after replacement: '$replace_result'"

# Concatenate two strings
str1="Hello"
str2="Shell"
concat_result=$(string_concatenate "$str1" "$str2")
echo "Concatenation of '$str1' and '$str2' is: '$concat_result'"

2.	Write a shell script program for different arithmetic functions.
#!/bin/bash

# Function to add two numbers
add() {
    local num1=$1
    local num2=$2
    echo $(($num1 + $num2))
}

# Function to subtract two numbers
subtract() {
    local num1=$1
    local num2=$2
    echo $(($num1 - $num2))
}

# Function to multiply two numbers
multiply() {
    local num1=$1
    local num2=$2
    echo $(($num1 * $num2))
}

# Function to divide two numbers
divide() {
    local num1=$1
    local num2=$2
    if [ $num2 -ne 0 ]; then
        echo $(($num1 / $num2))
    else
        echo "Error: Division by zero"
    fi
}

# Function to find the modulus of two numbers
modulus() {
    local num1=$1
    local num2=$2
    echo $(($num1 % $num2))
}

# Main script execution
echo "Arithmetic Functions in Shell Script"

# Example numbers
num1=20
num2=10

# Addition
result_add=$(add $num1 $num2)
echo "$num1 + $num2 = $result_add"

# Subtraction
result_subtract=$(subtract $num1 $num2)
echo "$num1 - $num2 = $result_subtract"

# Multiplication
result_multiply=$(multiply $num1 $num2)
echo "$num1 * $num2 = $result_multiply"

# Division
result_divide=$(divide $num1 $num2)
echo "$num1 / $num2 = $result_divide"

# Modulus
result_modulus=$(modulus $num1 $num2)
echo "$num1 % $num2 = $result_modulus"

# Additional examples with different numbers
num3=15
num4=4

# Addition
result_add=$(add $num3 $num4)
echo "$num3 + $num4 = $result_add"

# Subtraction
result_subtract=$(subtract $num3 $num4)
echo "$num3 - $num4 = $result_subtract"

# Multiplication
result_multiply=$(multiply $num3 $num4)
echo "$num3 * $num4 = $result_multiply"

# Division
result_divide=$(divide $num3 $num4)
echo "$num3 / $num4 = $result_divide"

# Modulus
result_modulus=$(modulus $num3 $num4)
echo "$num3 % $num4 = $result_modulus"

echo "Arithmetic functions demo completed."

3.	Write a shell script program for a number to check whether it is
1.	palindrome
2.	prime
3.	generate Fibonacci series
           #!/bin/bash

# Function to check if a number is a palindrome
is_palindrome() {
    local num=$1
    local reverse_num=$(echo $num | rev)
    if [ "$num" -eq "$reverse_num" ]; then
        echo "$num is a palindrome."
    else
        echo "$num is not a palindrome."
    fi
}

# Function to check if a number is prime
is_prime() {
    local num=$1
    if [ $num -le 1 ]; then
        echo "$num is not a prime number."
        return
    fi
    for ((i = 2; i * i <= num; i++)); do
        if [ $((num % i)) -eq 0 ]; then
            echo "$num is not a prime number."
            return
        fi
    done
    echo "$num is a prime number."
}

# Function to generate Fibonacci series up to n terms
generate_fibonacci() {
    local n=$1
    local a=0
    local b=1
    echo "Fibonacci series up to $n terms:"
    for ((i = 0; i < n; i++)); do
        echo -n "$a "
        local temp=$a
        a=$b
        b=$((temp + a))
    done
    echo
}

# Main script execution
echo "Number Checking and Fibonacci Series in Shell Script"

# Example number for palindrome and prime check
example_num=121

# Check if the number is a palindrome
is_palindrome $example_num

# Check if the number is prime
is_prime $example_num

# Example number of terms for Fibonacci series
num_terms=10

# Generate Fibonacci series
generate_fibonacci $num_terms

# Additional examples:

# Check if another number is a palindrome
another_num=12321
is_palindrome $another_num

# Check if another number is prime
another_prime_num=17
is_prime $another_prime_num

# Generate another Fibonacci series with a different number of terms
another_num_terms=15
generate_fibonacci $another_num_terms

echo "Number checking and Fibonacci series demo completed."
